---
slug: view-transitions-react-router
title: View Transitions in React Router 7
description: A deep dive into React Router 7's View Transitions API‚Äîhow it works, what it's good for, limitations, gotchas, and how to make it feel polished with live examples.
tags:
  - react
  - react-router
  - animations
  - web-platform
visual:
  prompt: 'Abstract geometric shapes morphing and transitioning smoothly between states, gradient colors flowing between pages, modern tech aesthetic, seamless transformation'
  image:
    url: 'https://replicate.com/black-forest-labs/flux-1.1-pro'
    version: '6418bec016044867bc892d4ba01844a94c7274009e6f2224dd0aa8a9edd950be'
  video:
    url: 'https://replicate.com/bytedance/seedance-1-pro-fast'
    version: bytedance/seedance-1-pro-fast
links:
  'View Transitions API': 'https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API'
  'React Router Docs': 'https://reactrouter.com/start/framework/view-transitions'
  'Can I Use View Transitions': 'https://caniuse.com/view-transitions'
  'PR #20': 'https://github.com/superhighfives/code/pull/20'
---

I spent a weekend adding View Transitions to this site, and honestly? It was one of those moments where you feel like you're living in the future. Click any link on this page. Go ahead, I'll wait.

Did you see that? The way the content slides up and fades in, staggered across the page? That's the View Transitions API working with React Router 7. And the best part? It's basically a one-line change in your components.

But here's the thing: making it feel *good* takes more than adding `viewTransition` to your links. I learned a lot about when to use morphing (and when not to), how to handle loading states, and what the gotchas are. Let's dive in.

## What Are View Transitions?

The View Transitions API is a web platform feature that lets you create smooth, animated transitions between different states of your page. Think of it like the transitions you see in native mobile apps‚Äîwhen you tap a photo and it smoothly expands to fill the screen, that's a view transition.

React Router 7 has native support for this API. Instead of the typical instant page change, you can coordinate animations between elements on the old page and elements on the new page. The browser handles the hard part (capturing screenshots, managing timing, coordinating animations), and you just declare what you want to transition.

Here's the simplest possible example:

```jsx live
import { useState } from 'react'

export default function App() {
  const [page, setPage] = useState('home')

  const navigate = (to) => {
    document.startViewTransition(() => {
      setPage(to)
    })
  }

  return (
    <div className="p-8">
      <nav className="flex gap-4 mb-8">
        <button
          onClick={() => navigate('home')}
          className="px-4 py-2 bg-blue-500 text-white rounded"
        >
          Home
        </button>
        <button
          onClick={() => navigate('about')}
          className="px-4 py-2 bg-blue-500 text-white rounded"
        >
          About
        </button>
      </nav>

      <main>
        {page === 'home' ? (
          <div>
            <h1 className="text-2xl font-bold mb-4">Home</h1>
            <p>This is the home page. Notice the fade transition?</p>
          </div>
        ) : (
          <div>
            <h1 className="text-2xl font-bold mb-4">About</h1>
            <p>This is the about page. The transition happens automatically!</p>
          </div>
        )}
      </main>
    </div>
  )
}
```

By default, you get a crossfade. The old content fades out while the new content fades in. It's subtle but makes the page feel more responsive and intentional.

## How React Router 7 Makes It Easy

The vanilla JavaScript API is fine, but React Router 7 makes it even simpler. Instead of manually calling `document.startViewTransition()`, you just add a prop to your Link component:

```jsx
<Link to="/about" viewTransition>
  About
</Link>
```

That's it. React Router automatically wraps the navigation in a view transition. No state management, no manual DOM manipulation, no fighting with React's rendering lifecycle.

On this site, I use it in several places. Here's the breadcrumb link from [post.tsx:180](app/routes/post.tsx#L180):

```jsx
<Link to="/" viewTransition className="...">
  Home
</Link>
```

And the post grid in [nav-block.tsx:32](app/components/nav-block.tsx#L32):

```jsx
<Link
  to={`/${post.slug}`}
  viewTransition
  className="..."
>
  {/* Post preview */}
</Link>
```

React Router handles all the timing, coordinates with the browser's animation frame, and even deals with race conditions if you navigate again before the transition finishes.

## Named Transitions: The Real Power

The default crossfade is nice, but the real magic happens with *named transitions*. These let you coordinate specific elements across routes, creating those smooth morphing animations where an element on one page transforms into an element on the next page.

You do this with the `viewTransitionName` CSS property:

```jsx live
import { useState } from 'react'

export default function App() {
  const [page, setPage] = useState('list')
  const [selected, setSelected] = useState(null)

  const items = [
    { id: 1, title: 'Red Square', color: 'bg-red-500' },
    { id: 2, title: 'Blue Circle', color: 'bg-blue-500' },
    { id: 3, title: 'Green Triangle', color: 'bg-green-500' },
  ]

  const navigate = (to, item = null) => {
    document.startViewTransition(() => {
      setPage(to)
      setSelected(item)
    })
  }

  if (page === 'detail' && selected) {
    return (
      <div className="p-8">
        <button
          onClick={() => navigate('list')}
          className="mb-4 text-blue-600 underline"
        >
          ‚Üê Back
        </button>
        <div
          className={`w-64 h-64 ${selected.color} rounded-lg flex items-center justify-center text-white text-2xl font-bold`}
          style={{ viewTransitionName: `item-${selected.id}` }}
        >
          {selected.title}
        </div>
        <p className="mt-4">Details about {selected.title}</p>
      </div>
    )
  }

  return (
    <div className="p-8">
      <h2 className="text-xl font-bold mb-4">Click an item</h2>
      <div className="grid gap-4">
        {items.map(item => (
          <div
            key={item.id}
            onClick={() => navigate('detail', item)}
            className={`w-32 h-32 ${item.color} rounded-lg flex items-center justify-center text-white font-bold cursor-pointer`}
            style={{ viewTransitionName: `item-${item.id}` }}
          >
            {item.title.split(' ')[0]}
          </div>
        ))}
      </div>
    </div>
  )
}
```

See how the colored square morphs and moves when you click it? That's because we gave it the same `viewTransitionName` on both pages. The browser captures the element's position, size, and appearance on the old page, then smoothly animates it to its new position on the next page.

**Important:** The `viewTransitionName` must be unique on each page. If you have a list of items, you need unique names for each one (like `item-${id}` in the example above).

## How This Site Uses View Transitions

I implemented view transitions in [PR #20](https://github.com/superhighfives/code/pull/20), and I made some specific choices about what to animate and how. Let me walk through the CSS in [global.css:461-573](app/global.css#L461-L573).

### The Default: Instant Disappear, Fade In

For most content, I don't use the default crossfade. Instead, old content disappears instantly, and new content fades in:

```css
::view-transition-old(root) {
  animation: none;
}

::view-transition-new(root) {
  animation: fade-in 0.3s cubic-bezier(0, 0, 0.2, 1);
}
```

Why? I found that crossfading felt sluggish. The old content hanging around created visual confusion about what you were supposed to look at. An instant switch followed by a quick fade-in feels snappier and more intentional.

### Staggered Content Reveal

The real polish comes from staggering the content reveal. Instead of everything appearing at once, each section slides up and fades in sequentially:

```css
::view-transition-new(post-breadcrumb) {
  animation: fade-up 0.5s cubic-bezier(0, 0, 0.2, 1);
  animation-delay: 0.2s;
}

::view-transition-new(post-metadata) {
  animation: fade-up 0.5s cubic-bezier(0, 0, 0.2, 1);
  animation-delay: 0.3s;
}

::view-transition-new(post-content) {
  animation: fade-up 0.5s cubic-bezier(0, 0, 0.2, 1);
  animation-delay: 0.4s;
}
```

Each section gets a 100ms delay increment. Breadcrumb first, then metadata, then content. This creates a cascading reveal that feels polished and purposeful.

You can see this in action in [post.tsx](app/routes/post.tsx) where each section gets its view transition name:

```jsx
<nav style={{ viewTransitionName: 'post-breadcrumb' }}>
  {/* Breadcrumb */}
</nav>

<header style={{ viewTransitionName: 'post-metadata' }}>
  {/* Title and date */}
</header>

<article style={{ viewTransitionName: 'post-content' }}>
  {/* Post content */}
</article>
```

Here's an interactive example you can customize:

```jsx live
import { useState } from 'react'

export default function App() {
  const [show, setShow] = useState(false)
  const [delays, setDelays] = useState([0, 100, 200, 300])

  const toggle = () => {
    document.startViewTransition(() => {
      setShow(!show)
    })
  }

  return (
    <div className="p-8">
      <button
        onClick={toggle}
        className="mb-8 px-6 py-3 bg-blue-500 text-white rounded-lg font-bold"
      >
        Toggle Content
      </button>

      {show && (
        <div className="space-y-4">
          {delays.map((delay, i) => (
            <div
              key={i}
              className="p-4 bg-gray-100 rounded"
              style={{
                viewTransitionName: `section-${i}`,
                animation: `fade-up 0.5s cubic-bezier(0, 0, 0.2, 1) ${delay}ms`
              }}
            >
              Section {i + 1} (delay: {delay}ms)
            </div>
          ))}
        </div>
      )}

      <div className="mt-8">
        <p className="mb-2 text-sm font-bold">Adjust delays:</p>
        {delays.map((delay, i) => (
          <div key={i} className="mb-2">
            <label className="text-sm">Section {i + 1}: {delay}ms</label>
            <input
              type="range"
              min="0"
              max="500"
              step="50"
              value={delay}
              onChange={(e) => {
                const newDelays = [...delays]
                newDelays[i] = parseInt(e.target.value)
                setDelays(newDelays)
              }}
              className="w-full"
            />
          </div>
        ))}
      </div>
    </div>
  )
}
```

### The Post Visual: No Morphing

The hero visual at the top of each post has a `viewTransitionName`, but I deliberately disabled morphing for it:

```css
::view-transition-group(post-visual) {
  animation: none !important;
}

::view-transition-new(post-visual) {
  animation: slide-down 0.7s cubic-bezier(0.34, 1.56, 0.64, 1);
}
```

Why disable morphing? I tried it with morphing enabled, and it looked weird. Each post has a different visual, and watching one visual morph into a completely different image was jarring‚Äînot in a good way. Instead, I have it slide down from the top with a bouncy easing curve.

Here's a comparison:

```jsx live
import { useState } from 'react'

export default function App() {
  const [page, setPage] = useState('red')
  const [useMorph, setUseMorph] = useState(false)

  const images = {
    red: { bg: 'bg-red-500', emoji: 'üî¥' },
    blue: { bg: 'bg-blue-500', emoji: 'üîµ' },
    green: { bg: 'bg-green-500', emoji: 'üü¢' },
  }

  const navigate = (to) => {
    document.startViewTransition(() => {
      setPage(to)
    })
  }

  const current = images[page]

  return (
    <div className="p-8">
      <div className="mb-4">
        <label className="flex items-center gap-2">
          <input
            type="checkbox"
            checked={useMorph}
            onChange={(e) => setUseMorph(e.target.checked)}
          />
          <span className="text-sm">Enable morphing</span>
        </label>
      </div>

      <nav className="flex gap-2 mb-8">
        {Object.keys(images).map(color => (
          <button
            key={color}
            onClick={() => navigate(color)}
            className="px-4 py-2 bg-gray-200 rounded"
          >
            {color}
          </button>
        ))}
      </nav>

      <div
        className={`w-full h-64 ${current.bg} rounded-lg flex items-center justify-center text-8xl`}
        style={{
          viewTransitionName: 'hero',
          animation: useMorph ? undefined : 'none'
        }}
      >
        {current.emoji}
      </div>

      <p className="mt-4 text-sm text-gray-600">
        {useMorph ? 'Morphing enabled - watch it try to blend' : 'Morphing disabled - clean transition'}
      </p>
    </div>
  )
}
```

Morphing works great when the content is similar (like a thumbnail expanding to a full image). But when the content is completely different, an instant cut often feels better.

### Persistent Navigation

The bottom navigation bar on this site doesn't animate during transitions. It stays completely stable:

```css
::view-transition-old(navigation),
::view-transition-new(navigation) {
  animation: none;
}
```

This is intentional. When navigation UI moves or fades during a transition, it feels unstable, like the ground is shifting under you. By keeping it fixed, it acts as an anchor point while the content changes.

## When to Use View Transitions vs Framer Motion

This site actually uses *both* the View Transitions API and Framer Motion. How do I decide which to use?

**Use View Transitions for:**
- Cross-route navigation (page to page)
- Morphing elements across routes
- Coordinated page transitions
- Progressive enhancement (works without JavaScript)

**Use Framer Motion for:**
- Local state changes (within a component)
- Complex animation choreography
- Gesture-based interactions
- When you need more control over timing

Example: The video player on post pages uses Framer Motion for playing/pausing because it's a local state change that doesn't involve navigation. But clicking links to other posts uses View Transitions because you're navigating between routes.

Here's a comparison:

```jsx live
import { useState } from 'react'
import { motion } from 'framer-motion' // ^11.0.0

export default function App() {
  const [approach, setApproach] = useState('view-transitions')
  const [isExpanded, setIsExpanded] = useState(false)

  const toggleViewTransition = () => {
    document.startViewTransition(() => {
      setIsExpanded(!isExpanded)
    })
  }

  const toggleFramerMotion = () => {
    setIsExpanded(!isExpanded)
  }

  const toggle = approach === 'view-transitions' ? toggleViewTransition : toggleFramerMotion

  return (
    <div className="p-8">
      <div className="mb-8">
        <p className="text-sm mb-2">Approach:</p>
        <div className="flex gap-2">
          <button
            onClick={() => setApproach('view-transitions')}
            className={`px-4 py-2 rounded ${approach === 'view-transitions' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
          >
            View Transitions
          </button>
          <button
            onClick={() => setApproach('framer-motion')}
            className={`px-4 py-2 rounded ${approach === 'framer-motion' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
          >
            Framer Motion
          </button>
        </div>
      </div>

      <button
        onClick={toggle}
        className="mb-8 px-6 py-3 bg-green-500 text-white rounded-lg font-bold"
      >
        Toggle
      </button>

      {approach === 'view-transitions' ? (
        isExpanded ? (
          <div
            className="w-full h-64 bg-purple-500 rounded-lg flex items-center justify-center text-white text-2xl"
            style={{ viewTransitionName: 'box' }}
          >
            Expanded
          </div>
        ) : (
          <div
            className="w-32 h-32 bg-purple-500 rounded-lg flex items-center justify-center text-white"
            style={{ viewTransitionName: 'box' }}
          >
            Small
          </div>
        )
      ) : (
        <motion.div
          className="bg-purple-500 rounded-lg flex items-center justify-center text-white"
          animate={isExpanded ? { width: '100%', height: 256 } : { width: 128, height: 128 }}
          transition={{ type: 'spring', stiffness: 300, damping: 30 }}
        >
          {isExpanded ? 'Expanded' : 'Small'}
        </motion.div>
      )}

      <p className="mt-4 text-sm text-gray-600">
        {approach === 'view-transitions'
          ? 'View Transitions: Browser-native, automatic morphing'
          : 'Framer Motion: Spring physics, full control'}
      </p>
    </div>
  )
}
```

View Transitions feel more "native" and handle complex transforms automatically. Framer Motion gives you precise control over physics, gestures, and complex sequences.

## Loading States for Heavy Pages

Here's a gotcha I ran into: if a page takes a while to load (heavy images, data fetching, whatever), the view transition can feel broken. You click a link, nothing happens for a second, then suddenly content appears. It's confusing.

There are a few solutions:

### 1. Prefetch Data

React Router 7 supports prefetching with the `prefetch` prop:

```jsx
<Link to="/heavy-page" viewTransition prefetch="intent">
  Heavy Page
</Link>
```

This starts loading the route when you hover or focus the link. By the time you click, the data's already there.

### 2. Loading Skeleton

Show a loading state that itself participates in the view transition:

```jsx
export async function loader() {
  // Long data fetch...
}

export default function Component() {
  const data = useLoaderData()

  if (!data) {
    return (
      <div style={{ viewTransitionName: 'content' }}>
        <Skeleton />
      </div>
    )
  }

  return (
    <div style={{ viewTransitionName: 'content' }}>
      <RealContent data={data} />
    </div>
  )
}
```

### 3. Timeout Fallback

If loading takes too long, bail out of the transition:

```jsx
const navigate = () => {
  const timeout = setTimeout(() => {
    // If still loading after 500ms, just navigate instantly
    window.location.href = '/heavy-page'
  }, 500)

  document.startViewTransition(async () => {
    await loadData()
    clearTimeout(timeout)
    // Render new page
  })
}
```

Here's an interactive example:

```jsx live
import { useState, useEffect } from 'react'

export default function App() {
  const [page, setPage] = useState('home')
  const [loading, setLoading] = useState(false)
  const [delay, setDelay] = useState(1000)

  const navigate = (to) => {
    setLoading(true)

    document.startViewTransition(async () => {
      // Simulate slow data fetch
      await new Promise(resolve => setTimeout(resolve, delay))
      setPage(to)
      setLoading(false)
    })
  }

  return (
    <div className="p-8">
      <div className="mb-4">
        <label className="text-sm">Loading delay: {delay}ms</label>
        <input
          type="range"
          min="0"
          max="3000"
          step="100"
          value={delay}
          onChange={(e) => setDelay(parseInt(e.target.value))}
          className="w-full"
        />
      </div>

      <nav className="flex gap-4 mb-8">
        <button
          onClick={() => navigate('home')}
          className="px-4 py-2 bg-blue-500 text-white rounded"
          disabled={loading}
        >
          Home
        </button>
        <button
          onClick={() => navigate('heavy')}
          className="px-4 py-2 bg-blue-500 text-white rounded"
          disabled={loading}
        >
          Heavy Page
        </button>
      </nav>

      <main style={{ viewTransitionName: 'content' }}>
        {loading ? (
          <div className="space-y-4">
            <div className="h-8 bg-gray-200 rounded animate-pulse" />
            <div className="h-4 bg-gray-200 rounded animate-pulse" />
            <div className="h-4 bg-gray-200 rounded animate-pulse w-3/4" />
          </div>
        ) : page === 'home' ? (
          <div>
            <h1 className="text-2xl font-bold mb-4">Home</h1>
            <p>Try navigating to the heavy page with different delays.</p>
          </div>
        ) : (
          <div>
            <h1 className="text-2xl font-bold mb-4">Heavy Page</h1>
            <p>This page took {delay}ms to load. The loading skeleton made it feel intentional!</p>
          </div>
        )}
      </main>
    </div>
  )
}
```

The key is giving users feedback. A loading skeleton that smoothly transitions keeps the experience feeling polished even when things take time.

## Browser Support and Limitations

Let's talk about the elephant in the room: browser support.

**Currently supported:**
- Chrome 111+ (March 2023)
- Edge 111+ (March 2023)
- Safari 18+ (September 2024)
- Opera 97+ (April 2023)

**Not supported:**
- Firefox (no implementation yet, though it's on their roadmap)
- Any browser from before 2023

That's a pretty good baseline for progressive enhancement‚Äîabout 70% of users globally as of writing. But it means you need to think about the fallback experience.

The good news? If the browser doesn't support View Transitions, React Router 7 just does a normal instant navigation. Your site still works, it just doesn't have the fancy animations.

**Performance considerations:**

1. **Low-end devices**: Complex transitions can stutter on older phones
2. **Reduced motion**: Always respect `prefers-reduced-motion`
3. **Memory**: The browser keeps screenshots in memory during transitions
4. **Paint cost**: Large view transitions mean more pixels to composite

Here's how to handle reduced motion preferences:

```css
@media (prefers-reduced-motion: reduce) {
  ::view-transition-old(*),
  ::view-transition-new(*) {
    animation: none !important;
  }
}
```

This disables all view transition animations for users who've indicated they prefer reduced motion. It's a small piece of CSS that makes your site more accessible.

## Common Gotchas

After implementing view transitions on this site, here are the gotchas I ran into:

### 1. Unique Names Required

Every `viewTransitionName` must be unique on a page. If you have duplicates, only the last one works. This is tricky with lists:

```jsx
// ‚ùå Bad - duplicate names
{posts.map(post => (
  <div style={{ viewTransitionName: 'post' }} key={post.id}>
    {post.title}
  </div>
))}

// ‚úÖ Good - unique names
{posts.map(post => (
  <div style={{ viewTransitionName: `post-${post.id}` }} key={post.id}>
    {post.title}
  </div>
))}
```

### 2. Hydration Mismatches

If you set `viewTransitionName` on the server but it's different on the client, React will complain about hydration mismatches. This can happen with dynamic names based on state that changes between server and client.

Solution: Either make the name deterministic (based on props/params) or set it client-side only with `useEffect`.

### 3. Z-index Stacking Issues

During a view transition, the browser creates pseudo-elements with specific stacking contexts. This can interact weirdly with your existing z-index values.

I had this issue with the navigation‚Äîit would sometimes disappear behind transitioning content. Fixed it by explicitly setting the z-index on the navigation's view transition:

```css
::view-transition-group(navigation) {
  z-index: 100;
}
```

### 4. Nested View Transitions

You can't nest view transitions. If you try to start a new transition while one is running, it cancels the first one. This can create jarring experiences if users click quickly.

React Router handles this reasonably well by canceling the previous transition, but you might want to disable links during transitions:

```jsx
const [isTransitioning, setIsTransitioning] = useState(false)

const navigate = (to) => {
  if (isTransitioning) return

  setIsTransitioning(true)
  // ... transition logic
}
```

### 5. Safari Quirks

Safari's implementation is newer and has some differences:

- Timing can be slightly different than Chrome
- Some CSS properties don't interpolate as smoothly
- Memory management is more aggressive (transitions might be skipped on low memory)

Always test on actual Safari, not just Chrome DevTools emulating Safari.

### 6. CSS Animation Names

Be careful with your CSS animation names. If you have an animation named `fade-in` and you also use `::view-transition-new(fade-in)`, you can get conflicts. I prefix my view transition names to avoid this:

```css
/* Animation */
@keyframes fade-up { ... }

/* View transition - different name */
::view-transition-new(post-content) {
  animation: fade-up 0.5s;
}
```

## Reviewing This Site's Implementation

Let me step back and critique what I built. What works well, and what could be better?

### What Works Well

**The staggered reveal feels polished.** The breadcrumb ‚Üí metadata ‚Üí content cascade creates a sense of hierarchy and intention. It doesn't feel like the browser is struggling‚Äîit feels choreographed.

**Navigation stability is crucial.** By keeping the navigation fixed and not animating it, it acts as an anchor point. You always know where you are, which makes the transitions feel less disorienting.

**Disabling visual morphing was the right call.** Each post's visual is unique, and morphing between them looked weird. The slide-down animation with the bouncy easing feels playful and matches the site's personality.

### What Could Be Better

**1. Add prefetching strategy**

Right now, I'm not prefetching anything. Adding `prefetch="intent"` to post links would make transitions feel even snappier:

```jsx
<Link
  to={`/${post.slug}`}
  viewTransition
  prefetch="intent" // Add this
  className="..."
>
  {/* Post preview */}
</Link>
```

**2. Loading indicators for post content**

MDX parsing and code highlighting happen server-side, which can take a moment. A loading skeleton would make this feel more intentional:

```jsx
export default function Post() {
  const { post } = useLoaderData()

  return (
    <article style={{ viewTransitionName: 'post-content' }}>
      {post ? <PostContent post={post} /> : <PostSkeleton />}
    </article>
  )
}
```

**3. Reduced motion preferences**

I should add a check for `prefers-reduced-motion` and disable transitions for users who prefer less motion:

```css
@media (prefers-reduced-motion: reduce) {
  ::view-transition-old(*),
  ::view-transition-new(*) {
    animation: none !important;
    animation-delay: 0s !important;
  }
}
```

**4. Mobile optimization**

The transition durations feel good on desktop but might be too long on mobile. I could adjust them with a media query:

```css
@media (max-width: 768px) {
  ::view-transition-new(post-content) {
    animation-duration: 0.3s; /* Faster on mobile */
    animation-delay: 0.2s;
  }
}
```

**5. Transition timeout**

If a transition takes more than, say, 500ms, it starts to feel broken. I could add a timeout that cancels the transition and just navigates instantly:

```jsx
const [isPending, startTransition] = useTransition()

const navigate = (to) => {
  const timeout = setTimeout(() => {
    if (isPending) {
      // Cancel and navigate instantly
      window.location.href = to
    }
  }, 500)

  startTransition(() => {
    clearTimeout(timeout)
    // Normal transition
  })
}
```

### Suggested Improvements

Here's what I'd add to [global.css](app/global.css#L461-L573):

```css
/* Add reduced motion support */
@media (prefers-reduced-motion: reduce) {
  ::view-transition-old(*),
  ::view-transition-new(*) {
    animation: none !important;
    animation-delay: 0s !important;
  }
}

/* Faster transitions on mobile */
@media (max-width: 768px) {
  ::view-transition-new(post-breadcrumb),
  ::view-transition-new(post-metadata),
  ::view-transition-new(post-content) {
    animation-duration: 0.3s;
    animation-delay: 0.1s;
  }

  ::view-transition-new(post-visual) {
    animation-duration: 0.4s;
  }
}

/* Smoother easing for some transitions */
::view-transition-new(post-content) {
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
}
```

And in the components, add prefetching:

```jsx
// nav-block.tsx
<Link
  to={`/${post.slug}`}
  viewTransition
  prefetch="intent"  // ‚Üê Add this
  className="..."
>
```

## Practical Tips and Best Practices

After all this experimentation, here's what I'd recommend:

### Start Simple

Don't try to animate everything at once. Start with just the default crossfade, then add named transitions one at a time. You can always add more polish later.

### Keep Durations Short

Anything over 500ms starts to feel sluggish. Most of my transitions are 300-500ms with small delays for staggering. Fast feels snappy; slow feels broken.

### Use the DevTools Timeline

Chrome DevTools has a great Animation timeline that shows you exactly when view transitions are happening. Use it to debug timing issues and see how your animations actually look frame-by-frame.

### Test on Real Devices

View transitions can stutter on low-end devices. Test on actual phones, not just browser emulation. If it's janky, reduce the complexity or disable transitions on slower devices.

### Respect User Preferences

Always check for `prefers-reduced-motion`. Some users get motion sickness or find animations distracting. Respecting their preferences makes your site more accessible.

### Name Elements Semantically

Use descriptive names like `post-breadcrumb` instead of `thing-1`. It makes your CSS easier to understand and debug.

### Consider the Fallback

Remember that a significant portion of users won't see your transitions (Firefox, older browsers, reduced motion preferences). Make sure your site works great without them.

### Don't Morph Different Content

Just because you *can* morph between elements doesn't mean you *should*. If the content is completely different, a clean cut with a fade often feels better than a morph.

## Timing Functions Matter

The easing curve you choose makes a huge difference in how a transition feels. Here's an interactive playground to compare them:

```jsx live
import { useState } from 'react'

export default function App() {
  const [isMoving, setIsMoving] = useState(false)
  const [easing, setEasing] = useState('cubic-bezier(0, 0, 0.2, 1)')

  const easings = {
    'Linear': 'linear',
    'Ease': 'ease',
    'Ease In': 'ease-in',
    'Ease Out': 'ease-out',
    'Ease In Out': 'ease-in-out',
    'Bounce': 'cubic-bezier(0.34, 1.56, 0.64, 1)',
    'Fast Out Slow In': 'cubic-bezier(0.4, 0, 0.2, 1)',
    'Fast Out Linear In': 'cubic-bezier(0.4, 0, 1, 1)',
  }

  const toggle = () => {
    document.startViewTransition(() => {
      setIsMoving(!isMoving)
    })
  }

  return (
    <div className="p-8">
      <div className="mb-4">
        <p className="text-sm mb-2 font-bold">Easing function:</p>
        <div className="grid grid-cols-2 gap-2">
          {Object.entries(easings).map(([name, curve]) => (
            <button
              key={name}
              onClick={() => setEasing(curve)}
              className={`px-3 py-2 rounded text-sm ${easing === curve ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
            >
              {name}
            </button>
          ))}
        </div>
      </div>

      <button
        onClick={toggle}
        className="mb-8 px-6 py-3 bg-green-500 text-white rounded-lg font-bold"
      >
        Animate
      </button>

      <div className="relative h-32 bg-gray-100 rounded">
        <div
          className="absolute top-1/2 -translate-y-1/2 w-16 h-16 bg-blue-500 rounded-lg"
          style={{
            viewTransitionName: 'box',
            left: isMoving ? 'calc(100% - 4rem)' : '0',
            transition: `left 1s ${easing}`
          }}
        />
      </div>

      <p className="mt-4 text-sm text-gray-600 font-mono">
        {easing}
      </p>
    </div>
  )
}
```

My favorites:
- `cubic-bezier(0, 0, 0.2, 1)` for fades (subtle deceleration)
- `cubic-bezier(0.34, 1.56, 0.64, 1)` for bouncy effects (overshoots slightly)
- `cubic-bezier(0.16, 1, 0.3, 1)` for smooth morphs (strong deceleration)

## Wrapping Up

View Transitions in React Router 7 are genuinely exciting. They bring native app-like polish to the web with minimal code. But like any tool, they work best when used thoughtfully.

My advice? Start simple. Add `viewTransition` to your links and see how the default crossfade feels. Then, if it makes sense for your site, add named transitions for specific elements. Stagger your content reveal. Disable morphing when it looks weird. Respect user preferences. Test on real devices.

The web platform is getting really good at this stuff. View Transitions, Container Queries, the Popover API‚Äîthere are so many new tools that make it easier to build polished, accessible experiences. I'm excited to see what we build with them.

If you want to see the full implementation, check out [PR #20](https://github.com/superhighfives/code/pull/20) on this site's repo. And if you have questions or want to share your own view transition experiments, I'd love to hear about them.

Now go make something that feels smooth.
